/*
 * PROJET : REMOTE LORA - HYBRIDE WIFI/PHYSIQUE
 * CIBLE  : Seeed Studio XIAO ESP32C6
 * VERSION: 7.0 (Contrôle total bouton dans le mode WiFi + Sortie manuelle)
 */

#include <Arduino.h>
#include <SPI.h>
#include <LoRa.h>
#include <WiFi.h>
#include <WebServer.h>
#include "driver/gpio.h"

// --- CONFIGURATION LORA ---
#define DEVICE_ID           0x77 
#define LORA_FREQUENCY      433E6
#define LORA_SF             11     
#define LORA_BW             125E3  
#define LORA_CR             5      
#define LORA_TX_POWER       17     // 17dBm (Compromis Portée/Batterie)
#define LORA_SYNC_WORD      0xF3

// PROTOCOLE
#define CMD_RELAY_ON        0xA1
#define CMD_RELAY_OFF       0xB2
#define ACK_RELAY_IS_ON     0xD4
#define ACK_RELAY_IS_OFF    0xE5

// PINOUT
#define PIN_LORA_RST    D0
#define PIN_LORA_NSS    D1
#define PIN_LORA_DIO0   D2
#define PIN_BUTTON      D3
#define PIN_LORA_MOSI   D4
#define PIN_LORA_MISO   D5
#define PIN_LORA_SCK    D6

// LEDS
#define PIN_LED_BLUE    D8   // WiFi / Tx
#define PIN_LED_RED     D9   // Erreur
#define PIN_LED_GREEN   D10  // Succès

// TIMINGS
#define FEEDBACK_DURATION   3000  // Réduit à 3s en mode WiFi pour fluidité
#define WIFI_TIMEOUT_MS     300000 // 5 min inactivité

WebServer server(80);
volatile unsigned long lastActivityTime = 0;
String webStatus = "EN ATTENTE...";

// MEMOIRE PERSISTANTE
RTC_DATA_ATTR bool nextActionIsOn = true; 
RTC_DATA_ATTR int bootCount = 0; 

const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML><html><head><title>Remote Control</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="refresh" content="5">
<style>body{font-family:sans-serif;background:#121212;color:#eee;text-align:center;padding:20px}
.btn{width:100%;padding:20px;margin:10px 0;font-size:20px;border:none;border-radius:5px;color:#fff;cursor:pointer}
.on{background:#27ae60}.off{background:#c0392b}.ref{background:#2980b9}</style>
</head><body><h1>CONTROLE TERRAIN</h1><p>Etat: <b>%STATUS%</b></p>
<a href="/on"><button class="btn on">ALLUMER</button></a><a href="/off"><button class="btn off">ETEINDRE</button></a>
<a href="/status"><button class="btn ref">ACTUALISER</button></a></body></html>)rawliteral";

// --- UTILITAIRES ---
void ledsOff() {
    digitalWrite(PIN_LED_BLUE, LOW);
    digitalWrite(PIN_LED_RED, LOW);
    digitalWrite(PIN_LED_GREEN, LOW);
}

void initLoRa() {
    SPI.begin(PIN_LORA_SCK, PIN_LORA_MISO, PIN_LORA_MOSI, PIN_LORA_NSS);
    LoRa.setPins(PIN_LORA_NSS, PIN_LORA_RST, PIN_LORA_DIO0);
    if (!LoRa.begin(LORA_FREQUENCY)) return;
    LoRa.setSpreadingFactor(LORA_SF);
    LoRa.setSignalBandwidth(LORA_BW);
    LoRa.setCodingRate4(LORA_CR);
    LoRa.setSyncWord(LORA_SYNC_WORD);
    LoRa.setTxPower(LORA_TX_POWER);
}

// --- ENVOI COMMANDE LORA ---
int sendCmd(uint8_t cmd) {
    // Flash Bleu rapide TX
    digitalWrite(PIN_LED_BLUE, HIGH); delay(50); digitalWrite(PIN_LED_BLUE, LOW);
    
    for(int attempt = 1; attempt <= 3; attempt++) {
        LoRa.beginPacket(); LoRa.write(DEVICE_ID); LoRa.write(cmd); LoRa.endPacket();
        
        unsigned long s = millis();
        while(millis() - s < 2000) { // 2s Timeout
            if(LoRa.parsePacket()) {
                if(LoRa.available() >= 2) {
                    uint8_t id = LoRa.read(); uint8_t r = LoRa.read();
                    if(id == DEVICE_ID) {
                        if(r == ACK_RELAY_IS_ON) return 1;
                        if(r == ACK_RELAY_IS_OFF) return 2;
                    }
                }
            }
        }
        delay(100); 
    }
    return 0; 
}

// --- EXÉCUTION LOGIQUE MÉTIER (Commune Web et Bouton) ---
// Retourne : 1 (Succès ON), 2 (Succès OFF), 0 (Echec)
int executeAction(bool turnOn) {
    lastActivityTime = millis(); // Reset timeout WiFi
    initLoRa(); // S'assurer que LoRa est prêt
    
    int result = 0;
    if(turnOn) result = sendCmd(CMD_RELAY_ON);
    else result = sendCmd(CMD_RELAY_OFF);

    // Feedback Visuel & Mise à jour Etat
    ledsOff(); // Reset LEDs
    
    if (result == 1) {
        webStatus = "ALLUME";
        nextActionIsOn = false;
        digitalWrite(PIN_LED_GREEN, HIGH);
        delay(1000); // Feedback court
    } 
    else if (result == 2) {
        webStatus = "ETEINT";
        nextActionIsOn = true;
        digitalWrite(PIN_LED_RED, HIGH);
        delay(1000);
    } 
    else {
        webStatus = "ERREUR COM";
        // 3 Flashs Rouges
        for(int i=0; i<3; i++) { digitalWrite(PIN_LED_RED, HIGH); delay(100); digitalWrite(PIN_LED_RED, LOW); delay(100); }
    }
    
    ledsOff();
    return result;
}

// --- MODE WIFI HYBRIDE ---
void runWiFiMode() {
    Serial.println(">>> ENTREE MODE WIFI AP");
    digitalWrite(PIN_LED_BLUE, HIGH); // Bleu Fixe = WiFi Actif
    
    initLoRa();
    WiFi.softAP("TELECOMMANDE_SPORT", "admin1234");
    
    // Configuration Serveur Web
    server.on("/", [](){ String s=index_html; s.replace("%STATUS%", webStatus); server.send(200, "text/html", s); lastActivityTime=millis(); });
    server.on("/on", [](){ 
        executeAction(true); 
        server.sendHeader("Location","/"); server.send(303); 
        digitalWrite(PIN_LED_BLUE, HIGH); // Rallumer témoin WiFi après action
    });
    server.on("/off", [](){ 
        executeAction(false); 
        server.sendHeader("Location","/"); server.send(303); 
        digitalWrite(PIN_LED_BLUE, HIGH); // Rallumer témoin WiFi après action
    });
    server.on("/status", [](){ 
        server.sendHeader("Location","/"); server.send(303); lastActivityTime=millis(); 
    });
    
    server.begin();
    lastActivityTime = millis();

    // --- BOUCLE PRINCIPALE WIFI ---
    while(true) {
        // 1. Gestion Clients Web
        server.handleClient();

        // 2. Gestion Bouton Physique (Multifonction)
        if (digitalRead(PIN_BUTTON) == LOW) {
            unsigned long pressStart = millis();
            
            // Attente relâchement ou détection long press
            while(digitalRead(PIN_BUTTON) == LOW) {
                // Si appui maintenu > 5 secondes -> SORTIE DU MODE WIFI
                if(millis() - pressStart > 5000) {
                    Serial.println(">>> SORTIE MANUELLE WIFI");
                    // Animation de sortie (Clignote Bleu rapide)
                    for(int i=0; i<10; i++) { digitalWrite(PIN_LED_BLUE, !digitalRead(PIN_LED_BLUE)); delay(100); }
                    
                    WiFi.mode(WIFI_OFF);
                    ledsOff();
                    return; // Retour au main loop -> Dodo
                }
                delay(10);
            }
            
            // Si on arrive ici, c'est un Clic Court (< 5s)
            // -> On déclenche l'action LoRa (Toggle)
            if (nextActionIsOn) executeAction(true);
            else executeAction(false);
            
            // Après l'action (qui a éteint les LEDs), on rallume le Bleu
            // pour montrer qu'on est toujours en WiFi
            digitalWrite(PIN_LED_BLUE, HIGH);
        }

        // 3. Gestion Timeout Inactivité
        if(millis() - lastActivityTime > WIFI_TIMEOUT_MS) {
            Serial.println(">>> TIMEOUT WIFI");
            WiFi.mode(WIFI_OFF);
            return;
        }
        
        delay(5); // Petit repos CPU
    }
}

// --- LOGIQUE PRINCIPALE ---
void processAction() {
    Serial.println("Traitement...");
    unsigned long start = millis();

    // 1. ANALYSE TYPE APPUI (Court ou Long ?)
    // Tant que bouton appuyé
    while(digitalRead(PIN_BUTTON) == LOW) {
        // Animation d'attente (Clignote Bleu lent)
        if(millis() - start > 200) { // On commence à clignoter après 200ms
             if(((millis()-start)/250)%2==0) digitalWrite(PIN_LED_BLUE, HIGH);
             else digitalWrite(PIN_LED_BLUE, LOW);
        }

        // SI APPUI > 5 SECONDES -> GO WIFI
        if(millis() - start > 5000) {
            ledsOff();
            runWiFiMode(); // On entre dans la boucle WiFi infinie
            return; // Au retour, on sort de processAction pour aller dormir
        }
        delay(10);
    }
    ledsOff();

    // 2. SI RELÂCHÉ AVANT 5s -> ACTION LORA SIMPLE
    long pressDuration = millis() - start;
    if(pressDuration > 50) {
        initLoRa();
        
        // Action Toggle
        if (nextActionIsOn) executeAction(true);
        else executeAction(false);
        
        // Ici, contrairement au mode WiFi, on ne rallume pas le Bleu
        // On laisse le feedback vert/rouge puis on sort pour dormir.
    }
}

// --- SETUP ---
void setup() {
    bootCount++;
    pinMode(PIN_LED_BLUE, OUTPUT);
    pinMode(PIN_LED_RED, OUTPUT);
    pinMode(PIN_LED_GREEN, OUTPUT);
    ledsOff();
    pinMode(PIN_BUTTON, INPUT_PULLUP);
    
    Serial.begin(115200);
    unsigned long s = millis();
    while(!Serial && millis()-s < 500);
    
    Serial.println("\n--- BOOT ---");

    // Si réveil par bouton ou premier boot avec bouton appuyé
    if (digitalRead(PIN_BUTTON) == LOW) {
        processAction();
    }
}

void loop() {
    // Sécurité relâchement bouton
    while(digitalRead(PIN_BUTTON) == LOW) delay(10);
    
    ledsOff();
    LoRa.end();
    WiFi.mode(WIFI_OFF);
    
    Serial.println(">>> DODO");
    Serial.flush();
    Serial.end();

    gpio_set_direction((gpio_num_t)PIN_BUTTON, GPIO_MODE_INPUT);
    gpio_pullup_en((gpio_num_t)PIN_BUTTON);
    gpio_wakeup_enable((gpio_num_t)PIN_BUTTON, GPIO_INTR_LOW_LEVEL);
    esp_sleep_enable_gpio_wakeup();
    esp_light_sleep_start();

    // --- REVEIL ---
    Serial.begin(115200);
    unsigned long ws = millis();
    while(!Serial && (millis()-ws<1000));
    Serial.println("\n>>> REVEIL");
    
    processAction();
}
