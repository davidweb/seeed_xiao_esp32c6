/*
 * PROJET : REMOTE LORA - DIAGNOSTIC VISUEL (LEDs)
 * CIBLE  : Seeed Studio XIAO ESP32C6
 * VERSION: 4.0 (Architecture LightSleep sans Reboot)
 */

#include <Arduino.h>
#include <SPI.h>
#include <LoRa.h>
#include <WiFi.h>
#include <WebServer.h>
#include "driver/gpio.h"

// ==========================================
// --- CONFIGURATION ---
// ==========================================

#define DEVICE_ID           0x77 
#define LORA_FREQUENCY      433E6
#define LORA_SF             12
#define LORA_BW             125E3
#define LORA_CR             8
#define LORA_TX_POWER       20
#define LORA_SYNC_WORD      0xF3

#define CMD_RELAY_ON        0xA1
#define CMD_RELAY_OFF       0xB2
#define ACK_RELAY_IS_ON     0xD4
#define ACK_RELAY_IS_OFF    0xE5

// PINOUT XIAO ESP32C6
#define PIN_LORA_RST    D0
#define PIN_LORA_NSS    D1
#define PIN_LORA_DIO0   D2
#define PIN_BUTTON      D3  // GPIO 21
#define PIN_LORA_MOSI   D4
#define PIN_LORA_MISO   D5
#define PIN_LORA_SCK    D6

#define PIN_LED_BLUE    D8
#define PIN_LED_RED     D9
#define PIN_LED_GREEN   D10

#define FEEDBACK_DURATION   10000
#define WIFI_TIMEOUT_MS     300000
#define DEBUG_TIMEOUT_MS    120000 

WebServer server(80);
volatile unsigned long lastActivityTime = 0;
String webStatus = "EN ATTENTE...";
bool isFirstBoot = true; // Pour gérer le délai de 2min uniquement au branchement électrique

const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML><html><head><title>Remote</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>body{font-family:sans-serif;background:#121212;color:#eee;text-align:center;padding:20px}
.btn{width:100%;padding:20px;margin:10px 0;font-size:20px;border:none;border-radius:5px;color:#fff;cursor:pointer}
.on{background:#27ae60}.off{background:#c0392b}.ref{background:#2980b9}</style>
</head><body><h1>CONTROLE TERRAIN</h1><p>Etat: <b>%STATUS%</b></p>
<a href="/on"><button class="btn on">ALLUMER</button></a><a href="/off"><button class="btn off">ETEINDRE</button></a>
<a href="/status"><button class="btn ref">ACTUALISER</button></a></body></html>)rawliteral";

// ==========================================
// --- FONCTIONS UTILITAIRES ---
// ==========================================

void ledsOff() {
    digitalWrite(PIN_LED_BLUE, LOW);
    digitalWrite(PIN_LED_RED, LOW);
    digitalWrite(PIN_LED_GREEN, LOW);
}

void signalTx() {
    digitalWrite(PIN_LED_BLUE, HIGH); delay(50); digitalWrite(PIN_LED_BLUE, LOW);
}

void signalError() {
    ledsOff();
    Serial.println("!!! ERREUR (Signal Rouge) !!!");
    for(int i=0; i<5; i++) {
        digitalWrite(PIN_LED_RED, HIGH); delay(50);
        digitalWrite(PIN_LED_RED, LOW); delay(50);
    }
}

// --- INITIALISATION LORA ---
void initLoRa() {
    // On ne ré-initialise pas si c'est déjà fait, sauf besoin spécifique
    // Mais pour la robustesse, on le refait à chaque réveil "radio"
    SPI.begin(PIN_LORA_SCK, PIN_LORA_MISO, PIN_LORA_MOSI, PIN_LORA_NSS);
    LoRa.setPins(PIN_LORA_NSS, PIN_LORA_RST, PIN_LORA_DIO0);
    
    if (!LoRa.begin(LORA_FREQUENCY)) {
        Serial.println("ERREUR: LoRa Fail");
        signalError();
        return;
    }
    
    LoRa.setSpreadingFactor(LORA_SF);
    LoRa.setSignalBandwidth(LORA_BW);
    LoRa.setCodingRate4(LORA_CR);
    LoRa.setSyncWord(LORA_SYNC_WORD);
    LoRa.setTxPower(LORA_TX_POWER);
}

// --- ENVOI COMMANDE ---
int sendCmd(uint8_t cmd) {
    signalTx();
    Serial.print("Envoi 0x"); Serial.println(cmd, HEX);
    
    for(int i=0; i<2; i++) {
        LoRa.beginPacket(); LoRa.write(DEVICE_ID); LoRa.write(cmd); LoRa.endPacket();
        delay(30);
    }
    
    Serial.println("Attente ACK...");
    unsigned long s = millis();
    while(millis() - s < 4000) {
        if(LoRa.parsePacket()) {
            if(LoRa.available() >= 2) {
                uint8_t id = LoRa.read(); uint8_t r = LoRa.read();
                if(id == DEVICE_ID) {
                    if(r == ACK_RELAY_IS_ON) return 1;
                    if(r == ACK_RELAY_IS_OFF) return 2;
                }
            }
        }
        delay(10);
    }
    return 0;
}

// ==========================================
// --- LOGIQUE PRINCIPALE ---
// ==========================================

void processAction() {
    Serial.println(">>> Traitement Action Bouton");
    
    unsigned long start = millis();
    
    // 1. TANT QUE LE BOUTON EST APPUYÉ (Gestion Long Press)
    // On attend de voir si l'utilisateur maintient pour le WiFi
    while(digitalRead(PIN_BUTTON) == LOW) {
        
        // --- MODE WIFI (Appui > 5s) ---
        if(millis() - start > 5000) {
            Serial.println("--- ACTIVATION WIFI (AP) ---");
            digitalWrite(PIN_LED_BLUE, HIGH);
            
            initLoRa(); // Nécessaire pour envoyer les commandes via web
            WiFi.softAP("TELECOMMANDE_SPORT", "admin1234");
            Serial.print("IP: "); Serial.println(WiFi.softAPIP());
            
            server.on("/", [](){ String s=index_html; s.replace("%STATUS%", webStatus); server.send(200, "text/html", s); lastActivityTime=millis(); });
            server.on("/on", [](){ int res = sendCmd(CMD_RELAY_ON); webStatus=(res==1)?"ALLUME":"ERREUR"; server.sendHeader("Location","/"); server.send(303); lastActivityTime=millis(); });
            server.on("/off", [](){ int res = sendCmd(CMD_RELAY_OFF); webStatus=(res==2)?"ETEINT":"ERREUR"; server.sendHeader("Location","/"); server.send(303); lastActivityTime=millis(); });
            server.begin(); 
            
            lastActivityTime = millis();
            
            // Boucle WiFi
            while(true) { 
                server.handleClient(); 
                // Timeout Wifi
                if(millis()-lastActivityTime > WIFI_TIMEOUT_MS) {
                    Serial.println("Fin WiFi -> Retour veille.");
                    WiFi.mode(WIFI_OFF);
                    return; // On sort de la fonction pour aller dormir
                }
                delay(2); 
            }
        }
        delay(10); // Petit délai pour ne pas saturer le CPU dans la boucle while
    }

    // 2. BOUTON RELACHÉ (Clic court ou long < 5s)
    // Si on est arrivé ici, c'est que le bouton a été relâché avant 5s
    // On vérifie qu'il a été appuyé au moins 50ms (anti-rebond)
    long pressDuration = millis() - start;
    
    if(pressDuration > 50) {
        initLoRa();
        int result = 0;

        if(pressDuration > 1500) {
            Serial.println("CMD: OFF (Clic long)");
            result = sendCmd(CMD_RELAY_OFF);
        } else {
            Serial.println("CMD: ON (Clic court)");
            result = sendCmd(CMD_RELAY_ON);
        }

        // Feedback
        if (result == 1) {
            Serial.println("SUCCES ON");
            digitalWrite(PIN_LED_GREEN, HIGH); delay(FEEDBACK_DURATION); 
        } else if (result == 2) {
            Serial.println("SUCCES OFF");
            digitalWrite(PIN_LED_RED, HIGH); delay(3000); 
        } else {
            Serial.println("ECHEC / NO ACK");
            signalError();
        }
    } else {
        Serial.println("Appui trop court (parasite ?)");
    }
    
    ledsOff();
}

// ==========================================
// --- SETUP & LOOP ---
// ==========================================

void setup() {
    pinMode(PIN_LED_BLUE, OUTPUT);
    pinMode(PIN_LED_RED, OUTPUT);
    pinMode(PIN_LED_GREEN, OUTPUT);
    ledsOff();

    // Configuration explicite du bouton
    pinMode(PIN_BUTTON, INPUT_PULLUP);
    
    Serial.begin(115200);
    delay(2000); 

    // --- FENÊTRE DE DIAGNOSTIC (Uniquement au 1er boot électrique) ---
    if (isFirstBoot && digitalRead(PIN_BUTTON) == HIGH) { 
        Serial.println("\n--- MODE DEBUG (2min) ---");
        unsigned long debugStart = millis();
        bool actionDetected = false;
        
        while(millis() - debugStart < DEBUG_TIMEOUT_MS) {
            if(digitalRead(PIN_BUTTON) == LOW) {
                actionDetected = true;
                break; // On sort pour traiter l'action
            }
            // Heartbeat visuel lent
            if ((millis() / 1000) % 2 == 0) digitalWrite(PIN_LED_BLUE, HIGH);
            else digitalWrite(PIN_LED_BLUE, LOW);
            delay(50);
        }
        
        ledsOff();
        
        // Si on a appuyé sur le bouton pendant le debug, on traite l'action tout de suite
        if(actionDetected) {
            processAction();
        }
    }
    
    // Le setup est fini, on passe au loop qui gère la veille
    isFirstBoot = false; 
}

void loop() {
    // 1. MISE EN VEILLE
    // Avant de dormir, on s'assure que tout est éteint
    ledsOff();
    LoRa.end();
    WiFi.mode(WIFI_OFF);
    
    Serial.println("\n>>> DODO (En attente D3...)");
    Serial.flush(); // IMPORTANT : attendre la fin des logs

    // CONFIGURATION CRITIQUE POUR REVEIL ESP32-C6 VIA GPIO
    // 1. Activer le mode INPUT
    gpio_set_direction((gpio_num_t)PIN_BUTTON, GPIO_MODE_INPUT);
    // 2. FORCER LE PULL-UP (Essentiel sur C6 pour wake-up LOW)
    gpio_pullup_en((gpio_num_t)PIN_BUTTON);
    // 3. Activer le réveil sur niveau bas
    gpio_wakeup_enable((gpio_num_t)PIN_BUTTON, GPIO_INTR_LOW_LEVEL);
    // 4. Activer la fonctionnalité wake-up
    esp_sleep_enable_gpio_wakeup();
    
    // 5. Light Sleep (Le CPU s'arrête mais la RAM est conservée)
    esp_light_sleep_start();

    // -----------------------------------------------------------
    // 2. REVEIL
    // Le code reprend EXACTEMENT ICI après l'appui sur le bouton
    // -----------------------------------------------------------
    
    Serial.println(">>> REVEIL !");
    
    // Petite pause pour stabiliser le signal bouton
    delay(10); 
    
    // On traite l'action (envoi LoRa ou WiFi)
    // Note : Le bouton est probablement encore appuyé par l'utilisateur à ce moment précis
    processAction();
    
    // Une fois l'action finie (ou timeout WiFi), la boucle loop() recommence
    // et nous renvoie en sommeil au point 1.
}
