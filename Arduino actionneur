/*
 * PROJET : ACTUATOR LORA - V2.0 INDUSTRIEL
 * FONCTIONS : RESTAURATION ETAT + ANTI-REPLAY + RSSI FEEDBACK
 */

#include <Arduino.h>
#include <SPI.h>
#include <LoRa.h>
#include <Preferences.h> // Pour mémoire état & sécurité

// --- CONFIGURATION IDENTIQUE EMETTEUR ---
#define DEVICE_ID           0x77 
#define LORA_FREQUENCY      433E6
#define LORA_SF             11     
#define LORA_BW             125E3  
#define LORA_CR             5
#define LORA_TX_POWER       17     
#define LORA_SYNC_WORD      0xF3

#define CMD_RELAY_ON        0xA1
#define CMD_RELAY_OFF       0xB2
#define ACK_RELAY_IS_ON     0xD4
#define ACK_RELAY_IS_OFF    0xE5
#define AUTO_OFF_TIMEOUT    14400000 // 4 Heures

// PINOUT ESP32
#define PIN_LORA_SS     5
#define PIN_LORA_RST    14
#define PIN_LORA_DIO0   2
#define PIN_RELAY       4   
#define PIN_LORA_MOSI   23
#define PIN_LORA_MISO   19
#define PIN_LORA_SCK    18

QueueHandle_t cmdQueue;
Preferences preferences;
unsigned long relayOnTime = 0;
bool isRelayOn = false;
uint32_t lastStoredCode = 0; // Sécurité

// --- TÂCHE 1 : LOGIQUE RELAIS & RESTAURATION ---
void taskRelay(void *pvParameters) {
    pinMode(PIN_RELAY, OUTPUT); 
    
    // --- RESTAURATION ETAT APRES COUPURE ---
    preferences.begin("actuator", false); // Namespace "actuator"
    isRelayOn = preferences.getBool("state", false); // Défaut OFF
    lastStoredCode = preferences.getUInt("lastcode", 0); // Défaut 0
    
    // Application immédiate de l'état (Anti-Glitch)
    digitalWrite(PIN_RELAY, isRelayOn ? HIGH : LOW);
    if(isRelayOn) {
        Serial.println("BOOT: RESTAURATION -> ON");
        relayOnTime = millis(); // On relance le timer auto-off
    } else {
        Serial.println("BOOT: RESTAURATION -> OFF");
    }
    preferences.end();

    uint8_t cmd;
    for (;;) {
        if (xQueueReceive(cmdQueue, &cmd, pdMS_TO_TICKS(1000)) == pdTRUE) {
            // Ouverture NVS pour sauvegarde
            preferences.begin("actuator", false);
            
            if (cmd == CMD_RELAY_ON) { 
                Serial.println("CMD: ON");
                digitalWrite(PIN_RELAY, HIGH); 
                isRelayOn = true; 
                relayOnTime = millis();
                preferences.putBool("state", true); // Sauvegarde
            } 
            else if (cmd == CMD_RELAY_OFF) { 
                Serial.println("CMD: OFF");
                digitalWrite(PIN_RELAY, LOW); 
                isRelayOn = false; 
                preferences.putBool("state", false); // Sauvegarde
            }
            
            preferences.end();
        }

        // Auto-Off
        if (isRelayOn && (millis() - relayOnTime > AUTO_OFF_TIMEOUT)) { 
            Serial.println("AUTO-OFF TIMER");
            digitalWrite(PIN_RELAY, LOW); 
            isRelayOn = false; 
            
            // On sauvegarde l'extinction
            preferences.begin("actuator", false);
            preferences.putBool("state", false);
            preferences.end();
        }
    }
}

// --- TÂCHE 2 : RADIO SECURISEE ---
void taskLoRa(void *pvParameters) {
    SPI.begin(PIN_LORA_SCK, PIN_LORA_MISO, PIN_LORA_MOSI, PIN_LORA_SS);
    LoRa.setPins(PIN_LORA_SS, PIN_LORA_RST, PIN_LORA_DIO0);
    
    if (!LoRa.begin(LORA_FREQUENCY)) {
        Serial.println("LoRa Init Failed!"); vTaskDelete(NULL);
    }
    
    LoRa.setSpreadingFactor(LORA_SF);
    LoRa.setSignalBandwidth(LORA_BW);
    LoRa.setCodingRate4(LORA_CR);
    LoRa.setSyncWord(LORA_SYNC_WORD);
    LoRa.setTxPower(LORA_TX_POWER);
    LoRa.setGain(0); // AGC

    Serial.println("LoRa Ready.");

    for (;;) {
        int packetSize = LoRa.parsePacket();
        if (packetSize >= 6) { // [ID, CMD, C1, C2, C3, C4] = 6 octets min
            
            uint8_t id = LoRa.read();
            uint8_t cmd = LoRa.read();
            
            // Reconstruction du Rolling Code (Big Endian)
            uint32_t receivedCode = 0;
            receivedCode |= ((uint32_t)LoRa.read() << 24);
            receivedCode |= ((uint32_t)LoRa.read() << 16);
            receivedCode |= ((uint32_t)LoRa.read() << 8);
            receivedCode |= (uint32_t)LoRa.read();

            // Mesure Signal
            int currentRssi = LoRa.packetRssi();

            if (id == DEVICE_ID) {
                Serial.printf("RX Code: %u (Last: %u) | RSSI: %d\n", receivedCode, lastStoredCode, currentRssi);

                // --- VERIFICATION SECURITE (ANTI-REPLAY) ---
                // On accepte si le code est strictement supérieur au dernier connu
                // Exception : Si le code reçu est très petit (< 20) et le stocké très grand, 
                // on suppose un Reset Batterie Télécommande -> On accepte et on resynchronise.
                
                bool accept = false;
                if (receivedCode > lastStoredCode) accept = true;
                else if (receivedCode < 20 && lastStoredCode > 1000) accept = true; // Resync après changement pile

                if (accept) {
                    // Mise à jour Sécurité
                    lastStoredCode = receivedCode;
                    preferences.begin("actuator", false);
                    preferences.putUInt("lastcode", lastStoredCode);
                    preferences.end();

                    // Traitement Commande
                    if (cmd == CMD_RELAY_ON || cmd == CMD_RELAY_OFF) { 
                        xQueueSend(cmdQueue, &cmd, 0);
                    }
                    
                    // --- ENVOI ACK AVEC RSSI ---
                    uint8_t ack = isRelayOn ? ACK_RELAY_IS_ON : ACK_RELAY_IS_OFF;
                    if(cmd == CMD_RELAY_ON) ack = ACK_RELAY_IS_ON; // Anticipation pour réactivité
                    if(cmd == CMD_RELAY_OFF) ack = ACK_RELAY_IS_OFF;

                    vTaskDelay(pdMS_TO_TICKS(50)); // Tempo RX
                    
                    LoRa.beginPacket(); 
                    LoRa.write(DEVICE_ID); 
                    LoRa.write(ack);
                    LoRa.write((uint8_t)currentRssi); // On renvoie le RSSI mesuré !
                    LoRa.endPacket(); 
                    LoRa.receive();
                    Serial.println("-> ACK SENT w/ RSSI");
                    
                } else {
                    Serial.println("!!! SECURITY REJECT (REPLAY ATTACK) !!!");
                }
            }
        }
        vTaskDelay(pdMS_TO_TICKS(10)); 
    }
}

void setup() {
    Serial.begin(115200);
    cmdQueue = xQueueCreate(10, sizeof(uint8_t));
    xTaskCreatePinnedToCore(taskLoRa, "LoRa", 4096, NULL, 5, NULL, 1);
    xTaskCreatePinnedToCore(taskRelay, "Relay", 2048, NULL, 1, NULL, 0);
}

void loop() { vTaskDelete(NULL); }
