/*
 * PROJET : ACTUATOR LORA - EDITION SPORT
 * CIBLE  : ESP32 Dev Module
 * ARCHI  : FreeRTOS Dual Core
 */

#include <Arduino.h>
#include <SPI.h>
#include <LoRa.h>

// --- CONFIGURATION STRICTEMENT IDENTIQUE A L'EMETTEUR ---
#define DEVICE_ID           0x77 
#define LORA_FREQUENCY      433E6
#define LORA_SF             11     // SF11
#define LORA_BW             125E3  // BW 125
#define LORA_CR             5
#define LORA_TX_POWER       17     
#define LORA_SYNC_WORD      0xF3

#define CMD_RELAY_ON        0xA1
#define CMD_RELAY_OFF       0xB2
#define CMD_GET_STATUS      0xC3
#define ACK_RELAY_IS_ON     0xD4
#define ACK_RELAY_IS_OFF    0xE5
#define AUTO_OFF_TIMEOUT    14400000 // 4 Heures (Sécurité)

// PINOUT ESP32 CLASSIC
#define PIN_LORA_SS     5
#define PIN_LORA_RST    14
#define PIN_LORA_DIO0   2
#define PIN_RELAY       4   // Pin qui pilote le gros relais
#define PIN_LORA_MOSI   23
#define PIN_LORA_MISO   19
#define PIN_LORA_SCK    18

QueueHandle_t cmdQueue;
unsigned long relayOnTime = 0;
bool isRelayOn = false;

// --- TÂCHE 1 : GESTION RELAIS (Core 0) ---
void taskRelay(void *pvParameters) {
    pinMode(PIN_RELAY, OUTPUT); 
    digitalWrite(PIN_RELAY, LOW); 

    uint8_t cmd;
    for (;;) {
        // Attente commande dans la file
        if (xQueueReceive(cmdQueue, &cmd, pdMS_TO_TICKS(1000)) == pdTRUE) {
            if (cmd == CMD_RELAY_ON) { 
                Serial.println("ACTION: RELAIS ON");
                digitalWrite(PIN_RELAY, HIGH); 
                isRelayOn = true; 
                relayOnTime = millis(); 
            } 
            else if (cmd == CMD_RELAY_OFF) { 
                Serial.println("ACTION: RELAIS OFF");
                digitalWrite(PIN_RELAY, LOW); 
                isRelayOn = false; 
            }
        }

        // Sécurité : Extinction automatique après 4h
        if (isRelayOn && (millis() - relayOnTime > AUTO_OFF_TIMEOUT)) { 
            Serial.println("AUTO-OFF SAFETY");
            digitalWrite(PIN_RELAY, LOW); 
            isRelayOn = false; 
        }
    }
}

// --- TÂCHE 2 : GESTION RADIO (Core 1) ---
void taskLoRa(void *pvParameters) {
    SPI.begin(PIN_LORA_SCK, PIN_LORA_MISO, PIN_LORA_MOSI, PIN_LORA_SS);
    LoRa.setPins(PIN_LORA_SS, PIN_LORA_RST, PIN_LORA_DIO0);
    
    if (!LoRa.begin(LORA_FREQUENCY)) {
        Serial.println("ERREUR: LoRa Init Failed!");
        vTaskDelete(NULL);
    }
    
    // Config Radio
    LoRa.setSpreadingFactor(LORA_SF);
    LoRa.setSignalBandwidth(LORA_BW);
    LoRa.setCodingRate4(LORA_CR);
    LoRa.setSyncWord(LORA_SYNC_WORD);
    LoRa.setTxPower(LORA_TX_POWER);
    
    // IMPORTANT : Gain Automatique (AGC) pour gérer 10cm comme 3km
    LoRa.setGain(0); 

    Serial.println("LoRa Ready & Listening...");
    unsigned long lastPacketTime = 0;

    for (;;) {
        // Écoute permanente
        if (LoRa.parsePacket()) { 
            if(LoRa.available() >= 2) {
                uint8_t id = LoRa.read();
                uint8_t cmd = LoRa.read();
                uint8_t ack = 0;

                if (id == DEVICE_ID) {
                    Serial.print("CMD REÇUE: 0x"); Serial.println(cmd, HEX);
                    
                    // Anti-Replay sur l'action physique (1.5 sec)
                    // On filtre les doublons envoyés par la télécommande
                    bool isNewAction = (millis() - lastPacketTime > 1500);
                    
                    if (cmd == CMD_RELAY_ON) { 
                        if(isNewAction) { xQueueSend(cmdQueue, &cmd, 0); lastPacketTime = millis(); }
                        ack = ACK_RELAY_IS_ON; 
                    } 
                    else if (cmd == CMD_RELAY_OFF) { 
                        if(isNewAction) { xQueueSend(cmdQueue, &cmd, 0); lastPacketTime = millis(); }
                        ack = ACK_RELAY_IS_OFF; 
                    }
                    else if (cmd == CMD_GET_STATUS) { 
                        ack = isRelayOn ? ACK_RELAY_IS_ON : ACK_RELAY_IS_OFF; 
                    }

                    // ENVOI ACK IMMEDIATE
                    if(ack != 0) {
                        // Petite pause pour laisser la télécommande passer en RX
                        vTaskDelay(pdMS_TO_TICKS(50)); 
                        
                        LoRa.beginPacket(); 
                        LoRa.write(DEVICE_ID); 
                        LoRa.write(ack); 
                        LoRa.endPacket(); 
                        
                        // Retour immédiat en écoute
                        LoRa.receive(); 
                        Serial.println("-> ACK SENT");
                    }
                }
            }
        }
        // Yield pour éviter blocage watchdog
        vTaskDelay(pdMS_TO_TICKS(10)); 
    }
}

void setup() {
    Serial.begin(115200);
    
    // Création file de message
    cmdQueue = xQueueCreate(10, sizeof(uint8_t));

    // Lancement des tâches sur les deux cœurs
    xTaskCreatePinnedToCore(taskLoRa, "LoRa", 4096, NULL, 5, NULL, 1); // Core 1 (Radio)
    xTaskCreatePinnedToCore(taskRelay, "Relay", 2048, NULL, 1, NULL, 0); // Core 0 (Relais)
}

void loop() { 
    // Le loop est vide car tout est géré par FreeRTOS
    vTaskDelete(NULL); 
}
